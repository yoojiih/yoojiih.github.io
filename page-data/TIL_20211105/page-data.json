{"componentChunkName":"component---src-templates-blog-template-js","path":"/TIL_20211105/","result":{"data":{"cur":{"id":"22fb78a6-deda-5a44-b244-1f0593f15a75","html":"<h1 id=\"기능구현-후-성능향상--유지관리\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84-%ED%9B%84-%EC%84%B1%EB%8A%A5%ED%96%A5%EC%83%81--%EC%9C%A0%EC%A7%80%EA%B4%80%EB%A6%AC\" aria-label=\"기능구현 후 성능향상  유지관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기능구현 후 성능향상 &#x26; 유지관리</h1>\n<p>[ 컴포넌트 로딩속도 등을 향상시킴 ] </p>\n<h2 id=\"1익명함수object-사용-자제\" style=\"position:relative;\"><a href=\"#1%EC%9D%B5%EB%AA%85%ED%95%A8%EC%88%98object-%EC%82%AC%EC%9A%A9-%EC%9E%90%EC%A0%9C\" aria-label=\"1익명함수object 사용 자제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.익명함수/object 사용 자제</h2>\n<p>함수나 오브젝트는 변수에 담아쓰는게 좋음. 콜백하마수나 오브젝트 형식이 아닌 컴포넌트 바깥에 있는 변수에 저장해서 불러 씀\n-> 메모리공간을 아끼는 JS 관습\n컴포넌트 재렌더링 시 이름없는(변수에 저장안된) object, function 자료형 → 매번 새로운 메모리 영역을 할당해줘야하기 때문에 컴퓨터 바빠짐</p>\n<h2 id=\"2레이아웃에-애니메이션-사용-자제\" style=\"position:relative;\"><a href=\"#2%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83%EC%97%90-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EC%82%AC%EC%9A%A9-%EC%9E%90%EC%A0%9C\" aria-label=\"2레이아웃에 애니메이션 사용 자제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.레이아웃에 애니메이션 사용 자제</h2>\n<p>애니메이션 넣을 때 성능에 지장 없이 만들려면 자바스크립트, transition을 이용한 레이아웃 변경 애니메이션은 브라우저 입장에서는 큰 부담이니 사용 자제\n(레이아웃: width, margin, padding, left right top bottom 등)<br>\ntransform, opacity 같은 CSS 속성(transform은 사이즈 변경, 좌표이동, 회전 전부 가능한 속성)을 이용해 성능 지장 없게 만들어야함.</p>\n<h2 id=\"3-컴포넌트-lazy-loading-하기\" style=\"position:relative;\"><a href=\"#3-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-lazy-loading-%ED%95%98%EA%B8%B0\" aria-label=\"3 컴포넌트 lazy loading 하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 컴포넌트 lazy loading 하기</h2>\n<p>보통 App.js 라는 메인페이지 방문시 많은 컴포넌트 파일을 import 해오기 때문에 사이트 초기 접속속도가 굉장히 느려짐 (웹앱 사이트들의 특징)\n첫 페이지 방문시 import를 바로 해올 필요없는 컴포넌트는 필요해질 때 import 해달라고 할 수 있음</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, {useState, useContext, lazy, Suspense} from 'react';\nconst Detail = lazy( ()=>{ return import('./Detail.js') } );\n\nrender (\n  &lt;Suspense fallback={ &lt;div>로딩중&lt;/div> }>\n    &lt;Detail/>\n  &lt;/Suspense>\n)</code></pre></div>\n<blockquote>\n<ol>\n<li>react 라이브러리에서 lazy, Suspense를 import </li>\n<li>import Detail 대신 lazy 함수를 이용</li>\n<li><Suspense> 컴포넌트로 <Detail>을 감싸줌</li>\n<li><Detail> 컴포넌트가 필요해질 때 import Detail </li>\n<li><Suspense>의 fallback 속성을 이용해 <Detail> 컴포넌트 로딩 전까지 띄울 HTML 안내문 적을 수 있음</li>\n</ol>\n</blockquote>\n<h2 id=\"4-react-dev-tools-리액트-개발자-도구-크롬-확장프로그램\" style=\"position:relative;\"><a href=\"#4-react-dev-tools-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8F%84%EA%B5%AC-%ED%81%AC%EB%A1%AC-%ED%99%95%EC%9E%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8\" aria-label=\"4 react dev tools 리액트 개발자 도구 크롬 확장프로그램 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. React Dev Tools 리액트 개발자 도구 크롬 확장프로그램</h2>\n<p>크롬으로 구글에 react dev tools 검색해 설치시 크롬브라우저에서 우클릭 -> 검사 누르면 리액트 관련 탭 생김\nComponents탭\n→ 현재 페이지에 사용된 모든 컴포넌트들을 쭉 나열해 보여줌\n컴포넌트를 클릭시 사용중인 props, state, hook 표시해주기 때문에 </p>\n<ul>\n<li>props가 잘 전해졌는지, state가 잘 변하고 있는지 확인</li>\n<li>실시간 state, props 수정해보는것 가능</li>\n<li>시계모양 버튼 → 해당 컴포넌트 렌더링을 잠깐 정지</li>\n</ul>\n<p>Profiler탭\n→ 맨 왼쪽 녹화 버튼(파란점)을 눌러서 컴포넌트 렌더링 속도를 측정 가능\n버튼 누르고 사이트 탐색하고 버튼 다시 누르면 녹화가 완료되며 렌더링된 컴포넌트 다 기록되어 있음</p>\n<ul>\n<li>어떤 컴포넌트가 렌더링 시간이 젤 오래걸리는지</li>\n<li>쓸데없이 재렌더링 자주되는 컴포넌트가 있는지</li>\n<li>렌더링 필요없는 컴포넌트가 있는지 찾아낼 수 있음</li>\n</ul>\n<h2 id=\"5-memo\" style=\"position:relative;\"><a href=\"#5-memo\" aria-label=\"5 memo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. memo</h2>\n<p>리액트 앱은 컴포넌트와 관련된 state 혹은 props가 변경되면 항상 자동 재렌더링 됨 → 사이트 구동 속도가 저하\n컴포넌트의 규모가 너무 커 잦은 재렌더링이 부담스러울 때 쓰는 방법\n특히 컴포넌트안에 컴포넌트가 여러개 있을 때 유용함 (부모 컴포넌트를 구성하는 state나 props가 변경되면 해당 Props를 전달받는 자식 컴포넌트를 전부 자동 재렌더링 시키기 때문)\nmemo로 감싼 컴포넌트는 기존 props와 바뀐 props를 비교하는 연산이 추가로 진행되기 때문에 props가 크고 복잡하면 이거 자체로도 부담이 됨\n규모가 작은 사이트를 만들거나 컴포넌트 내부에 있는 HTML 양이 매우 적을 경우엔 사용 X</p>\n<p>Reference</p>\n<h1 id=\"설치\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EC%B9%98\" aria-label=\"설치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설치</h1>\n<p><code class=\"language-text\">touch tsconfig.json</code>\n<code class=\"language-text\">npm install --save-dev typescript @types/react @types/node</code>\n<code class=\"language-text\">npm run dev</code></p>","excerpt":"기능구현 후 성능향상 & 유지관리  컴포넌트 로딩속도 등을 향상시킴   1.익명함수/object 사용 자제 함수나 오브젝트는 변수에 담아쓰는게 좋음. 콜백하마수나 오브젝트 형식이 아닌 컴포넌트 바깥에 있는 변수에 저장해서 불러 씀\n -> 메모리공간을 아끼는 JS 관습\n컴포넌트 재렌더링 시 이름없는(변수에 저장안된) object, function 자료형 → 매번 새로운 메모리 영역을 할당해줘야하기 때문에 컴퓨터 바빠짐 2.레이아웃에 애니메이션 사용 자제 애니메이션 넣을 때 성능에 지장 없이 만들려면 자바스크립트, transition을 이용한 레이아웃 변경 애니메이션은 브라우저 입장에서는 큰 부담이니 사용 자제\n(레이아웃: width, margin, padding, left right top bottom 등) transform, opacity 같은 CSS 속성(transform은 사이즈 변경, 좌표이동, 회전 전부 가능한 속성)을 이용해 성능 지장 없게 만들어야함. 3. 컴포넌트 la…","frontmatter":{"date":"November 05, 2021","title":"Shop Project_성능 최적화","categories":"TIL","author":"yooji","emoji":null},"fields":{"slug":"/TIL_20211105/"}},"next":{"id":"f8024bc6-e485-50b9-b8f7-8f4bfe4360a2","html":"<p>Redux Middleware를 적용하기 전에 동기 &#x26; 비동기에 대해 짚고 넘어가고자 함</p>\n<h1 id=\"javascript-synchronous동기-asynchronous비동기-콜백함수\" style=\"position:relative;\"><a href=\"#javascript-synchronous%EB%8F%99%EA%B8%B0-asynchronous%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98\" aria-label=\"javascript synchronous동기 asynchronous비동기 콜백함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Javascript Synchronous(동기), Asynchronous(비동기), 콜백함수</h1>\n<h2 id=\"synchronous-asynchronous-의미\" style=\"position:relative;\"><a href=\"#synchronous-asynchronous-%EC%9D%98%EB%AF%B8\" aria-label=\"synchronous asynchronous 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Synchronous, Asynchronous 의미</h2>\n<ul>\n<li>동기: 하나의 요청이 오면 완료가 된 후 다음 요청을 실행하는 방식 (순차적으로 로직 수행됨)</li>\n<li>비동기: 어떤 요청이 오면 완료 되기 까지 기다리지 않고 다음 요청을 실행하는 방식\n→ 여러 작업을 동시에 효율적으로 처리하기 때문에 즉시 응답을 못받아 흐름을 정확히 파악해 그에 맞게 적절히 처리 되어야 예상밖의 결과가 나오는 것을 막을 수 있음 (순차적인 흐름을 보장하지 않음, 완료되면 실행, 물리적으로 잠시 보류) </li>\n<li>자바스크립트는 일반적인 코드 작성 시 synchronous(동기식)하게 코드 적은 순서대로 윗에서부터 한줄한줄 차례로 처리됨.</li>\n<li>ajax 요청, 이벤트 리스너, state 변경함수, setTimeout, 이런 함수들은 처리시간이 오래걸리기 때문에 사용 시 asynchronous (비동기적)으로 처리됨</li>\n</ul>\n<h2 id=\"콜백-함수\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98\" aria-label=\"콜백 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백 함수</h2>\n<p>비동기로 작성된 함수를 일부 구간에서 동기 처리(순차적 처리)하기 위한 하나의 방법론\n→ 독립적으로 수행되는 작업뿐만 아니라 응답을 받은 이후 처리 되어야하는 종속적인 작업에 대응 하기 위함</p>\n<h2 id=\"콜백-함수-형태\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98-%ED%98%95%ED%83%9C\" aria-label=\"콜백 함수 형태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백 함수 형태</h2>\n<p>보통 함수를 선언한 뒤에 함수 타입 파라미터를 맨 마지막에 하나 더 선언 해 주는 방식으로 정의\n처리가 끝나면 파라미터로 전달 받은 함수를 실행하며 필요한 경우 결과 값을 인자로 넘겨줄 수도 있음</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function mainFunc(param1, param2, callbackFunc) {\n// ... 처리 내용\n    callbackFunc(result);\n}</code></pre></div>\n<h2 id=\"적용-예시\" style=\"position:relative;\"><a href=\"#%EC%A0%81%EC%9A%A9-%EC%98%88%EC%8B%9C\" aria-label=\"적용 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>적용 예시</h2>\n<p>Synchronous(동기) Vs Asynchronous(비동기) 의미</p>\n<ul>\n<li>\n<p>동기식 (순차흐름)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function syn(alphabet, seq_1, seq_2) {\nconsole.log(\"B\");\n    var total = seq_1+seq_2;\nvar total = price*quantity;\nreturn total;\n}\n// 1과 2의 총합을 리턴해 tot변수에 대입 시켜주고 tot를 cal 함수의 파라미터로 넘겨줌\nvar tot = syn(\"A\", 1, 2);\ncal(tot);</code></pre></div>\n</li>\n<li>\n<p>1,000,000,000번 루프를 돌고, 이 작업이 얼마나 걸렸는지 알려주는 기능을 하는 <code class=\"language-text\">work()</code> 함수 호출 시 for 문이 돌아갈 때는 다른 작업은 처리하지 않고 온전히 for 문만 실행</p>\n<ul>\n<li>\n<p>Date.now -> 현재 시간을 숫자 형태로 가져오는 자바스크립트 내장 함수</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">work</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></code></pre></div>\n</li>\n</ul>\n<p>const start = Date.now();\nfor (let i = 0; i &#x3C; 1000000000; i++) {}\nconst end = Date.now();\nconsole.log(end - start + ‘ms’);\n}</p>\n</li>\n</ul>\n<p>work();\nconsole.log(‘다음 작업’);</p>\n<p>// 출력 값 -> 517ms 다음작업</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 비동기 방식 \nsetTimeout 함수를 사용하여 함수 안의 코드가 1초뒤에 출력이 완료되게 구현\n결과값 : A → undefined → B (1초 후 출력됨) \nsetTimeout함수 호출 시 다음 구문을 1초 뒤가 아닌 호출한 직후 실행하기 때문에 tot 변수에 아무 값도 받지 못한 상태로 C가 B보다 먼저 출력됨</code></pre></div>\n<p>function asyn(alphabet, seq<em>1, seq</em>2) {\nsetTimeout(function() {\nconsole.log(“B”);\nvar total = seq<em>1+seq</em>2;\nreturn total;\n}, 1000);\n}</p>\n<p>function asyn(alphabet, seq<em>1, seq</em>2) {\nvar tot = asyn(“A”, 1, 2);\ncal(tot);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 비동기에서 콜백함수를 이용한 동기처리 (feat. 콜백함수가 필요한 이유_동기 &amp; 비동기)\nB 이후의 행위를 기술하기 위해 콜백 함수를 인자로 받고 setTimeout 함수 내에 포함\n콜백 함수에 C를 기술시 결과값 : A → (1초뒤 출력)B → C(순차 실행 만족)</code></pre></div>\n<p>function buy<em>tobe(alphabet, seq</em>1, seq<em>2, callback) {\nsetTimeout(function() {\nconsole.log(“B”);\nvar total = seq</em>1+seq_2;\ncallback(total);\n}, 1000);\n}</p>\n<p>function cal(tot) {\nconsole.log(tot + “C”);\n}\n// cal 함수를 콜백 파라미터에 대입\nbuy<em>tobe(“A”, 1, 2, cal);\n// pay 함수를 따로 선언하지 않고 바로 익명함수 처리도 가능함\nbuy</em>tobe(“A”, 1, 2, function(tot) {\nconsole.log(tot + “C”);\n});</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 동기에서 비동기 처리\nfor문 돌아가는 동안 다른 작업도 하고싶으면 `setTimeout` 함수를 사용해 비동기 형태로 변환해 줘야함\n`setTimeout` 함수\n- 첫번째 파라미터에 넣은 함수를 두번째 파라미터에 넣은 시간(ms 단위)이 흐른 후 호출해줌\n- 정한 작업이 백그라운드에서 수행되기 때문에 기존의 코드 흐름을 막지 않고 동시에 다른 작업들을 진행 가능</code></pre></div>\n<p>function work() {\nsetTimeout(() => {\nconst start = Date.now();\nfor (let i = 0; i &#x3C; 1000000000; i++) {}\nconst end = Date.now();\nconsole.log(end - start + ‘ms’);\n}, 0);\n}</p>\n<p>console.log(‘작업 시작!’);\nwork();\nconsole.log(‘다음 작업’);\n//출력 값 -> 작업 시작! 다음 작업 508ms</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- work 함수가 끝난 다음에 어떤 작업을 처리하고 싶다면 콜백 함수를 파라미터로 전달해주면 됨\n콜백 함수 → 함수 타입의 값을 파라미터로 넘겨줘서, 파라미터로 받은 함수를 특정 작업이 끝나고 호출을 해주는 것</code></pre></div>\n<p>function work(callback) {\nsetTimeout(() => {\nconst start = Date.now();\nfor (let i = 0; i &#x3C; 1000000000; i++) {}\nconst end = Date.now();\nconsole.log(end - start + ‘ms’);\ncallback();\n}, 0);\n}</p>\n<p>console.log(‘작업 시작!’);\nwork(() => {\nconsole.log(‘작업이 끝났어요!‘)\n});\nconsole.log(‘다음 작업’);</p>\n<p>//출력 값 : 작업시작! 다음 작업 298ms 작업이 끝났어요!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">작업들을 비동기적으로 처리하게 되는 경우\n\n- Ajax Web API 요청: 서버쪽에서 데이터를 받아올 땐 요청 후 서버에서 응답 할 때까지 대기함\n- 파일 읽기: 주로 서버 쪽에서 파일을 읽어야 하는 상황\n- 암호화/복호화:  바로 처리가 되지 않고 시간이 어느정도 걸리는 경우가 있기 때문\n- 작업 예약: 단순히 어떤 작업을 몇초 후에 스케쥴링 해야 하는 상황에 setTimeout 을 사용\n- 비동기 작업을 다룰 때에는 callback 함수, Promise,  async/await 라는 문법을 사용해 처리 가능.\n\n# Promise\n[[typescript] Promise와 Async/Await 구문](https://hoony-gunputer.tistory.com/entry/typescript-Promise%EC%99%80-AsyncAwait-%EA%B5%AC%EB%AC%B8)\n\n## Promise란\n비동기 처리의 방법(콜백함수, Promise)중 하나\n비동기 함수를 동기식으로 처리하기 위해 고안한 객체\n-> 비동기 작업이 완료된 이후에 다음 작업을 연결시켜 진행할 수 있는 기능 + 작업 결과에 따라 성공 또는 실패를 리턴하며 결과 값을 전달받을 수 있음\n  기본적으로 promise는 함수에 콜백을 전달하는 대신에, 콜백을 첨부하는 방식의 객체임\n## Promise 기본 문법\n  `const myPromise = new Promise((resolve, reject) => { ... })`\n  Promise는 성공 시엔 resolve, 실패 시엔 reject 호출해줌\n  `resolve` 호출 시 \n    파라미터로 특정 값 넣어주면 이 값을 작업이 끝나고 나서 사용  가능하고\n    → 작업 끝난 후 또 다른 작업 해야할 땐 Promise 뒤에 `.then(...)` 을 붙여서 사용\n  `reject` 호출 시 \n    `.catch` 를 통해 실패했을 때 수행 할 작업을 설정 가능\n  \n## Promise의 3가지 상태 및 처리 흐름\nPromise 객체가 비동기 함수의 처리 상태를 보고 완료되었는지 판단하여 성공 여부에 따라 다음 처리를 다르게 수행할 수 있게 해줌\npending(대기) : 처리가 완료되지 않은 상태\nfulfilled(이행) : 성공적으로 처리가 완료된 상태\nrejected(거부) : 처리가 실패로 끝난 상태\n\n## then 체인 (직접 Promise를 return) \nthen 메서드 내 return 키워드 사용 시 결과 값이 기본 자료형이 아닌 Promise 객체로 반환됨\n각각의 함수가 Promise 객체를 리턴하는 비동기 작업이라고 가정한다면 then 메서드를 연속적으로 사용해 순차적인 작업 가능\nthen을 통해 반환한 값은 또 다른 then을 통해서 수신 가능하기 때문에 체인 형식이 가능하게 됨\n체이닝 기법을 활용함으로써 콜백 함수를 너무 많이 중첩 시 발생 가능한 콜백 지옥에 빠지지 않게 함</code></pre></div>\n<p>goA()\n.then(function(){\nreturn goB();\n})\n.then(function(){\nreturn goC();\n})\n.then(function(){\nreturn goD();\n});</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">### 콜백지옥 예시\n비동기 작업을 처리 할 때 콜백 함수로 처리 시 비동기 작업이 많아질 때 코드 깊이가 계속 깊어지는 Callback Hell (콜백지옥)현상이 발생하는데 이를 Promise 사용함으로서 방지 가능\n  - 파라미터로 숫자 n 받아와 다섯번에 걸쳐 1초마다 1씩 더해서 출력하는 작업을 setTimeout 으로 구현</code></pre></div>\n<p>  function increaseAndPrint(n, callback) {\nsetTimeout(() => {\nconst increased = n + 1;\nconsole.log(increased);\nif (callback) {\ncallback(increased);\n}\n}, 1000);\n}</p>\n<p>  increaseAndPrint(0, n => {\nincreaseAndPrint(n, n => {\nincreaseAndPrint(n, n => {\nincreaseAndPrint(n, n => {\nincreaseAndPrint(n, n => {\nconsole.log(‘끝!’);\n});\n});\n});\n});\n});</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># Promise 사용 시 문제점\nPromise 를 사용하면, 비동기 작업의 개수가 많아져도 코드의 깊이가 깊어지지 않지만\n에러를 잡을 때 몇번째에서 발생했는지 알아내기도 어렵고 특정 조건에 따라 분기를 나누는 작업도 어렵고, \n특정 값을 공유해가면서 작업을 처리하기도 까다로움 →  async/await 을 사용시 해결 가능\n\n# Async/Await\nPromise를 다루는 구문 (Promise 객체를 좀 더 쉽게 다룰 수 있게 고안된 문법)\n-> promise.then 사용보다 훨씬 간결하고 가독성 뛰어남\n비동기 함수를 동기 함수처럼 다룰 수 있어 매우 깔끔하고 유용하게 사용할 수 있는 방법\n\n## Await\n피연산자의 값을 반환해 줌 (피연산자가 Promise 객체면 then 메서드를 호출해 얻은 값을 반환)\nawait 키워드를 사용하더라도 그 작업이 처리되는 동안 다른 모든 프로세스가 중단되는 것은 아니며 엔진이 다른 일을 할 수 있으므로 자원이 효율적으로 운영됨\n- await 기본 예제\n앞에 async / await 키워드만 붙여주면 비동기 작업의 순차 처리가 동기적으로 처리로 가능</code></pre></div>\n<p>// 1초 후 hello 출력되는 코드\nfunction greet() {\nreturn new Promise(function(resolve){\nsetTimeout(function() {\nresolve(‘hello’);\n}, 1000);\n});\n}</p>\n<p>(async function() {\nvar result = await greet();//resolved 될 때까지 대기console.log(result);\n})();</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># Async\nawait구문은 항상 async 함수 안에서만 사용가능\nfunction 앞에 async 키워드만 붙여주면 됨 → 항상 Promise 객체를 반환해줌\nasync 함수에서는 Promise가 아닌 값을 리턴하더라도 내부적으로 Promise로 감싸서 resolved promise가 반환됨\n\nasync 함수의 성질\n\n- 일반함수 처럼 사용가능\n- promise 객체로도 사용 가능 -> Promise.all에도 적용해 사용 가능함\n- 값 반환 가능 (반환값은 Promise 형태로 변환되므로 then 메소드를 통해서 반환되는 값을 얻어야 함)\n- 제일 외부에서는 then을 통해서 값에 접근해야함</code></pre></div>\n<p>const hiasync = async()=>{\nawait Promise 객체 혹은 값\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<p>const hi = async ()=>{\nreturn [1, 2, 3];\n}</p>\n<p>const asyncReturn = async ()=>{\nconst result = await hi()\nconsole.log(‘value0:’, result)\nreturn result;\n}</p>\n<p>asyncReturn().then(value =>\nconsole.log(‘value1: ’, value))</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">결과</code></pre></div>\n<p>value0: [ 1, 2, 3 ]\nvalue1:  [ 1, 2, 3 ]</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  ## async/await 문법 → Promise 를 더욱 쉽게 사용 할 수 있게 해줌\n  \n  함수를 선언 할 때 함수 앞부분에 `async` 키워드를 붙이고 Promise의 앞부분에 `await` 을 넣어주면 \n  해당 프로미스가 끝날때까지 기다렸다가 다음 작업을 수행 가능\n  \n  `sleep` 함수의 파라미터에 넣어준 시간만큼 기다리는 Promise 를 만들고, 이를 `process` 함수 안에서 await 붙인 형태로 사용\n   &amp; `process` 함수 앞에 `async` 사용시 해당 함수는 결과값으로 Promise 를 반환하게 됨</code></pre></div>\n<p>  async function process() {\nconsole.log(‘A’);\nawait sleep(1000); // 1초쉬고\nconsole.log(‘B!’);\n}\nprocess().then(() => {\nconsole.log(‘C’);\n});</p>\n<p>  <code class=\"language-text\">async</code> 함수에서 에러를 발생 시 <code class=\"language-text\">throw</code>, 에러를 잡아낼 땐 try/catch 문을 사용</p>\n<p>  async function makeError() {\nawait sleep(1000);\nconst error = new Error();\nthrow error;\n}</p>\n<p>  async function process() {\ntry {\nawait makeError();\n} catch (e) {\nconsole.error(e);\n// 출력 값: Error\n}\n}</p>\n<p>  process();</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> </code></pre></div>\n<p>  function sleep(ms) {\nreturn new Promise(resolve => setTimeout(resolve, ms));\n}</p>\n<p>  const A = async () => {\nawait sleep(1000);\nreturn ‘가’;\n};</p>\n<p>  const B = async () => {\nawait sleep(500);\nreturn ‘나’;\n};\nconst C = async () => {\nawait sleep(3000);\nreturn ‘다’;\n};</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">동기적 처리시  (`A` -> `B` -> `C` 함수들을 순서대로 하나가 끝나야 다음작업이 실행되게 함)</code></pre></div>\n<p>  async function process() {\nconst a = await A();\nconsole.log(a);\nconst b = await B();\nconsole.log(b);\nconst c = await C();\nconsole.log(c);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">비동기적 처리 시 (동시에 작업을 시작하고 싶다면 Promise.all 을 사용해야 함)</code></pre></div>\n<p>  async function process() {\nconst results = await Promise.all([A(), B(), C()]);\nconsole.log(results);  // 출력값 : [“가”,“나”,“다”]\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 배열 비구조화 할당 문법을 사용시 각 결과값을 따로 따로 추출해서 조회 가능\n Promise.all를 사용 시 등록한 프로미스 중 하나라도 실패하면, 모든게 실패 한 것으로 간주</code></pre></div>\n<p>  async function process() {\nconst [a, b, c] = await Promise.all([\nA(),\nB(),\nC()\n]);\nconsole.log(a);\nconsole.log(b);\nconsole.log(c);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//Promise.race는 Promise.all과 달리, 여러개의 프로미스를 등록해서 실행했을 때 가장 빨리 끝난 Promise 하나만의 결과값을 가져옴\n가장 먼저 끝난 Promise가 실패시 이를 실패로 간주하기 때문에 B에서 에러를 발생시킨다면 에러를 잡아낼 수 있지만, C나 A에서 발생한 에러는 무시됨</code></pre></div>\n<p>  async function process() {\nconst first = await Promise.race([\nA(),\nB(),\nC()\n]);\nconsole.log(first);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<p>  process();</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\n\nReference\n\n[자바스크립트 async / await 예제](https://sangminem.tistory.com/479)</code></pre></div>","frontmatter":{"date":"November 04, 2021","title":"Shop Project_JavaScript_동기 비동기 콜백함수","categories":"TIL","author":"yooji","emoji":null},"fields":{"slug":"/TIL_20211104/"}},"prev":{"id":"c2c096bc-fe46-5af0-880e-b0f4bcede8ee","html":"<blockquote>\n<p>Test는 어떤 가설을 검증해 나가는 과정이며 고품질의 소프트웨어를 개발하기 위해선 꼭 필요한 기본 중의 기본\n왜 필요한가\n제대로 동작하는 소프트웨어를 작성하기 위함\n테스트를 수행하면서 소프트웨어에 대한 가설을 다시 되짚어 볼 수 있음\n일반적으로 소프트웨어를 테스트하는 과정을 통해 더 나은 코드를 작성할 수 있음\n테스트를 진행하다 보면 코드를 더 잘 이해할 수 있게 됨\n소프트웨어 개발 주기에 테스트를 통합함으로써 코드를 더 자주 릴리즈할 수 있게 됨\n코드를 리팩토링하거나 다른 위치로 옮길 때 큰 도움이 됨</p>\n</blockquote>\n<h2 id=\"tdd란\" style=\"position:relative;\"><a href=\"#tdd%EB%9E%80\" aria-label=\"tdd란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TDD란</h2>\n<p>Test Driven Development의 약자로 ‘테스트 주도 개발’이라고 하며 테스트케이스를 작성 한 후 실제 코드를 개발하여 리펙토링하는 절차를 따르기 때문에 Test First Development라고도 불림</p>\n<h2 id=\"언제-사용하면-좋은지\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80%EC%A7%80\" aria-label=\"언제 사용하면 좋은지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 사용하면 좋은지?</h2>\n<ol>\n<li>자신에 대한 불확실성이 높은 경우 (처음해보는 프로그램 주제)</li>\n<li>외부적인 불확실성이 높은 경우 (고객의 요구조건이 바뀔 수 있는 프로젝트)</li>\n<li>개발하는 중에 코드를 많이 바꿔야 하는 경우</li>\n<li>누가 유지보수할지 모르는 경우\n-> 만약 어떤 부분에 대한 코딩을 여러번 해봤고 결과가 어떻게 나올지 뻔하다면 TDD를 하지 않아도 된다</li>\n</ol>\n<h2 id=\"tdd의-효과\" style=\"position:relative;\"><a href=\"#tdd%EC%9D%98-%ED%9A%A8%EA%B3%BC\" aria-label=\"tdd의 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TDD의 효과</h2>\n<ol>\n<li>피드백 증진 시킴, 테스트 코드를 통해 자주 확인 가능</li>\n<li>협력을 증진 시킴\n모든 애자일의 실천법은 피드백과 협력을 동시에 증진시킴\n“test”가 명사가 된다면 즉, TDD가 된다면 공유가 쉬워진다. 다른 사람의 코드를 쉽게 접근가능하고, 이해가 빨라져 쉽게 의도 파악 가능</li>\n</ol>\n<h2 id=\"tdd-개발-방식의-장점\" style=\"position:relative;\"><a href=\"#tdd-%EA%B0%9C%EB%B0%9C-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"tdd 개발 방식의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TDD 개발 방식의 장점</h2>\n<ol>\n<li>보다 튼튼한 객체 지향적인 코드 생산</li>\n<li>TDD는 코드의 재사용 보장을 명시하므로 TDD를 통한 소프트웨어 개발 시 기능 별 철저한 모듈화가 이뤄진다. 이는 종속성과 의존성이 낮은 모듈로 조합된 소프트웨어 개발을 가능하게 하며 필요에 따라 모듈을 추가하거나 제거해도 소프트웨어 전체 구조에 영향을 미치지 않게 된다.</li>\n<li>재설계 시간의 단축</li>\n<li>테스트 코드를 먼저 작성하기 때문에 개발자가 지금 무엇을 해야하는지 분명히 정의하고 개발을 시작하게 된다. 또한 테스트 시나리오를 작성하면서 다양한 예외사항에 대해 생각해볼 수 있다. 이는 개발 진행 중 소프트웨어의 전반적인 설계가 변경되는 일을 방지할 수 있다.</li>\n<li>디버깅 시간의 단축</li>\n<li>이는 유닛 테스팅을 하는 이점이기도 하다. 예를 들면 사용자의 데이터가 잘못 나온다면 DB의 문제인지, 비즈니스 레이어의 문제인지 UI의 문제인지 실제 모든 레이러들을 전부 디버깅 해야하지만, TDD의 경우 자동화 된 유닛테스팅을 전재하므로 특정 버그를 손 쉽게 찾아낼 수 있다.</li>\n<li>테스트 문서의 대체 가능</li>\n<li>주로 SI 프로젝트 진행 과정에서 어떤 요소들이 테스트 되었는지 테스트 정의서를 만든다. 이것은 단순 통합 테스트 문서에 지나지 않는다. 하지만 TDD를 하게 될 경우 테스팅을 자동화 시킴과 동시에 보다 정확한 테스트 근거를 산출할 수 있다.</li>\n<li>추가 구현의 용이함</li>\n<li>개발이 완료된 소프트웨어에 어떤 기능을 추가할 때 가장 우려되는 점은 해당 기능이 기존 코드에 어떤 영향을 미칠지 알지 못한다는 것이다. 하지만 TDD의 경우 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있다.</li>\n</ol>\n<h2 id=\"tdd-개발-방식의-단점\" style=\"position:relative;\"><a href=\"#tdd-%EA%B0%9C%EB%B0%9C-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"tdd 개발 방식의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TDD 개발 방식의 단점</h2>\n<ul>\n<li>생산성의 저하</li>\n<li>처음부터 2개의 코드를 짜야하고, 테스트를 하면서 고쳐나가야 하기 때문에 개발 속도가 느려진다고 생각해 TDD에 대해 반신반의 함</li>\n<li>TDD 방식의 개발 시간은 일반적인 개발 방식에 비해 대략 10~30% 정도로 늘어난다.</li>\n<li>SI 프로젝트에서는 소프트웨어의 품질보다 납기일 준수가 훨씬 중요하기 때문에 TDD 방식을 잘 사용하지 않는다.</li>\n</ul>\n<h1 id=\"테스트의-종류\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"테스트의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트의 종류</h1>\n<p>유닛 테스트\n가장 작은 단위의 테스트이며 기능의 개별적인 단위를 테스트함\n보통 메서드 레벨, 시스템의 단일 구성 요소 검사, 즉각적인 피드팩 나옴, 리팩토링에 도움이 되며 모듈화를 증진\n코드가 제대로 작동하는지 확인하기 위해 애플리케이션의 개별 모듈을 독립적으로 테스트(종속성과의 상호 작용없이)\n즉, 하나의 메서드들이 잘 동작한다는 것은 보장할 수 있지만 결합되었을 때도 잘 작동한다는 것은 보장할 수 없음</p>\n<p>통합 테스트\n다른 모듈이 그룹으로 결합될 때 잘 작동하는지 확인\n모듈을 통합하는 과정에서 모듈 간 호환성의 문제를 찾아내기 위해 수행되는 테스트\n예를 들면, 유닛 테스트에서 데이터베이스에 접근하는 코드는 실제 데이터 베이스와 통신하는 것은 아니지만, 통합 테스트는 실제 통신해야 함\n보통 유닛 테스트를 작성하는 것보다 복잡하고 오랜 시간이 걸림</p>\n<p>기능 테스트\n모든 코드가 함께 실행되는 상태에서 시스템의 기능 조각을 테스트해 코드가 올바른 작업을 수행하는지 확인 (종속성과 상호 작용 할 수 있음)\n전체 애플리케이션의 기능을 확인하는 테스트,  인터페이스 자체를 이용해 진행\n시스템 요구 사항 사양에 설명 되어 있는 의도 된 기능에 대해 응용 프로그램 작동을 검사</p>\n<h2 id=\"테스팅-트로피\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8C%85-%ED%8A%B8%EB%A1%9C%ED%94%BC\" aria-label=\"테스팅 트로피 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스팅 트로피</h2>\n<p>Kent C. Dodds에 의해 잘 알려진 테스팅 트로피는 프론트엔드 테스트에서 두각을 보이는 방법</p>\n<p>통합 테스트가 투자 대비 얻는 것이 가장 많기 때문에 가장 큰 비중을 차지해야 한다고 권함\nEnd-to-End 테스트: 사용자 입장에서 전체 애플리케이션이 잘 동작하는 지 테스트하는 것\nIntegration(통합) 테스트: 실제 DB, 브라우저 없이 큰 규모의 기능이나 하나의 페이지가 잘 작동하는 지 테스트하는 것\nUnit(단위) 테스트: 기능의 개별적인 단위나 하나의 컴포넌트를 테스트함\nStatic 테스트: 구문 오류, 나쁜 코드 스타일, 잘못된 API 사용 등을 잡아줌</p>\n<h2 id=\"stub\" style=\"position:relative;\"><a href=\"#stub\" aria-label=\"stub permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stub</h2>\n<p>  아직 준비되지 못한 코드를 미리 정해진 답변으로 반환할 수 있도록 하는 메커니즘\n가짜 객체가 실제로 동작하는 것처럼 보이게 만들어놓은 객체이며, 호출자를 실제 구현물로부터 격리시켜 독립적인 테스트를 진행할 수 있도록 하는 것\n주로 </p>\n<ul>\n<li>복잡한 로직을 단순화 하고 싶을 떄</li>\n<li>구현이 되지 않은 함수가 있을 때</li>\n<li>라이브러리에서 제공하는 함수를 사용하고자 할 때</li>\n<li>의존성을 가지는 유닛의 응답을 모사하여 독립적인 테스트를 수행하고자 할 때 사용</li>\n</ul>\n<h2 id=\"mock\" style=\"position:relative;\"><a href=\"#mock\" aria-label=\"mock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mock</h2>\n<p>Mock은 가짜라는 의미인데, 이 Mock 이 사용되는 부분은 Mocking이라는 작업을 할 떄 사용됨\nMocking이란, 유닛 테스트 등을 작성할 때 해당 코드가 의존성을 가지고 있다면 그 부분을 직접 생성하는 것이 아닌 가짜로 대체하는 기법임</p>\n<h1 id=\"테스트-프레임워크-종류\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A2%85%EB%A5%98\" aria-label=\"테스트 프레임워크 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 프레임워크 종류</h1>\n<h2 id=\"jest\" style=\"position:relative;\"><a href=\"#jest\" aria-label=\"jest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jest</h2>\n<p>Jest란?\n단순함에 초점을 둔 페이스북에서 개발한 오픈 소스 자바스크립트 테스트 프레임워크\n비교적 사용이 간단하며 Babel, Typescript 등에 모두 사용가능\n테스트가 전역 상태를 갖도록 하여 모든 테스트를 평행적으로 수행이 가능하게 함\n또한 빠른 테스트를 위해 이전 테스트에서 실패했던 것을 가장 먼저 실행하고, 테스트의 수행 시간을 예측하여 실행 순서를 재배치\n—coverage Flag를 통해 테스트의 코드 커버리지를 간단하게 파악가능</p>\n<h2 id=\"mocha\" style=\"position:relative;\"><a href=\"#mocha\" aria-label=\"mocha permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mocha</h2>\n<p>Mocha는 Node.js와 브라우저에서 실행되는 기능이 풍부한 자바스크립트 테스트 프레임워크\n비동기식 테스트를 간단하게 진행 가능\n연속적으로 실행되어 유연하고 정확한 보고를 가능하게 하는 동시에 미검증 예외를 올바른 테스트 사례에 Mapping 함\n확장성이 좋아 여러가지 라이브러리 사용해 기능을 확장 가능</p>\n<h2 id=\"jasmine\" style=\"position:relative;\"><a href=\"#jasmine\" aria-label=\"jasmine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jasmine</h2>\n<p>Jasmine은 자바스크립트 코드를 테스트하기 위한 동작 중심 개발 프레임워크\n다른 Javascript 프레임워크에 의존하지 않으며, DOM이 필요하지 않아 구문 자체가 깨끗하고 명확해 쉽게 테스트 작성 가능\nMocha는 여러가지 라이브러리를 사용해야 했지만 Jasmine은 모든 기능을 통합해서 제공하기 때문에 추가적인 라이브러리가 필요 없음</p>\n<p>Reference\n<a href=\"https://pathas.tistory.com/231?category=897897\">참고</a>\n<a href=\"https://velog.io/@sms8377/Testing-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A2%85%EB%A5%98-%EB%B0%8F-Jest\">sms9377님 블로그</a></p>","frontmatter":{"date":"November 06, 2021","title":"Shop Project_TDD(Test-Driven-Development) 방법론","categories":"TIL","author":"yooji","emoji":null},"fields":{"slug":"/TIl_20211106/"}},"site":{"siteMetadata":{"siteUrl":"https://www.yoojiih.github.io","comments":{"utterances":{"repo":"yoojiih/yoojiih.github.io"}}}}},"pageContext":{"slug":"/TIL_20211105/","nextSlug":"/TIL_20211104/","prevSlug":"/TIl_20211106/"}},"staticQueryHashes":["1073350324","2938748437"]}