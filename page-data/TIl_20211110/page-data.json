{"componentChunkName":"component---src-templates-blog-template-js","path":"/TIl_20211110/","result":{"data":{"cur":{"id":"71859d6b-ccc4-5472-9632-85ebc1771534","html":"<p> [Testing] 테스트의 종류 및 Jest</p>\n<p>유닛 테스트, 통합 테스트, 기능 테스트\n유닛 테스트 : 코드가 제대로 작동하는지 확인하기 위해 애플리케이션의 개별 모듈을 독립적으로 테스트(종속성과의 상호 작용없이)하는 것을 의미합니다.\n통합 테스트 : 다른 모듈이 그룹으로 결합될 때 잘 작동하는지 확인하는 것을 의미합니다.\n기능 테스트 : 시스템의 기능 조각(종속성과 상호 작용 할 수 있음)을 테스트하여 코드가 올바른 작업을 수행하는지 확인하는 것을 의미합니다.\n기능 테스트는 통합 테스트와 관련이 있지만, 모든 코드가 함께 실행되는 상태에서 전체 애플리케이션의 기능을 확인하는 테스트를 의미합니다.</p>\n<p>단위 테스트는 시슽메의 단일 구성 요소 검사를 고려하는 반면, 기능 테스트는 시스템 요구 사항 사양에 설명 되어 있는 의도 된 기능에 대해 응용 프로그램 작동을 검사하는 것 입니다.</p>\n<p>유닛 테스트의 특징\n가장 작은 단위의 테스트이며, 보통 메서드 레벨입니다.\nA라는 함수가 실행되면 B라는 결과가 나온다 정도로 테스트합니다.\n즉각적인 피드백이 나온다는 것이 훌륭한 장점입니다.\n꼭 메모리 내에서만 실행되는 테스트여야 한다는 법칙은 없습니다.\nDB, Network Access, File System 등을 사용하여도 단위테스트의 레벨일 수 있습니다.\n하나의 메서드들이 잘 동작한다는 것은 보장할 수 있지만, 그들이 결합되었을 때도 잘 작동한다는 것은 보장할 수 없습니다.\n테스트하기 어려운 부분은 stub을 사용하여 테스트합니다.\n비용이 크지 않다면 stub 보다는 실제 객체를 사용하는 것이 좋습니다.\n아무래도 정교한 목 객체가 실제 객체보다 정확하지는 않기 때문입니다.\n모든 것은 비용 관점에서 생각해야 합니다.\nE2E 테스트의 특징\n해당 시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 시험하는 것을 말합니다.\n용어를 사용하는 곳마다 조금씩 차이가 있다고 합니다.\n내부 기능들까지(클래스의 메서드) 테스트 할 필요는 없습니다.\n이는 단위테스트의 영역입니다.\n단점은 테스트를 만들기가 힘들고, 만든 테스트를 신뢰하기도 힘들다는 것입니다.\n통합 테스트의 특징\n모듈을 통합하는 과정에서 모듈 간 호환성의 문제를 찾아내기 위해 수행되는 테스트입니다.\n유닛 테스트와의 차이점은 유닛 테스트는 다른 컴포넌트들과 도긻적인 반면 통합 테스트는 그렇지 않습니다.\n예를 들면, 유닛 테스트에서 데이터베이스에 접근하는 코드는 실제 데이터 베이스와 통신하는 것은 아니지만, 통합 테스트는 실제 통신해야 합니다.\n통합 테스트는 대게 유닛 테스트를 작성하는 것보다 복잡하고 오랜 시간이 걸립니다.\n꼭 필요한 것이 아니라면, 유닛 테스트를 작성하는데 집중하는 것이 좋습니다.\nStub과 Mock의 개념\nStub\nstub은 아직 준비되지 못한 코드를 미리 정해진 답변으로 반환할 수 있도록 하는 메커니즘입니다. 가짜 객체가 실제로 동작하는 것처럼 보이게 만들어놓은 객체이며, 호출자를 실제 구현물로부터 격리시켜 독립적인 테스트를 진행할 수 있도록 하는 것이 Stub입니다.</p>\n<p>Stub은 아래와 같은 경우 주로 사용 됩니다.</p>\n<p>복잡한 로직을 단순화 하고 싶을 떄\n구현이 되지 않은 함수가 있을 때\n라이브러리에서 제공하는 함수를 사용하고자 할 때\n의존성을 가지는 유닛의 응답을 모사하여 독립적인 테스트를 수행하고자 할 때\nMock\nMock은 가짜라는 의미인데, 이 Mock 이 사용되는 부분은 Mocking이라는 작업을 할 떄 사용됩니다.</p>\n<p>Mocking이란, 유닛 테스트 등을 작성할 때 해당 코드가 의존성을 가지고 있다면 그 의존하는 부분을 가짜로 대체하는 기법입니다. 일반적으로 유닛 테스트의 해당 코드가 의존하는 부분을 직접 생성하는 것이 까다로울 때 Mocking을 많이 사용합니다.</p>\n<p>Jest는 어떤 일을 하며 어떻게 사용하는 테스트 프레임워크일까요?</p>\n<p>Jest 이외의 테스트 프레임워크는 어떤 것이 있고 어떤 장단점이 있을까요?\nJest란?\nJest란 단순함에 초점을 둔 페이스북에서 개발한 오픈 소스 자바스크립트 테스트 프레임워크입니다. 비교적 사용이 간단하며 Babel, Typescript 등에 모두 사용할 수 있습니다.</p>\n<p>Jest는 테스트가 전역 상태를 갖도록 하여 모든 테스트를 평행적으로 수행이 가능하게 합니다. 또한 빠른 테스트를 위해 이전 테스트에서 실패했던 것을 가장 먼저 실행하고, 테스트의 수행 시간을 예측하여 실행 순서를 재배치합니다.</p>\n<p>테스트의 코드 커버리지를 파악할 땐 —coverage Flag를 통해 간단하게 파악할 수 있습니다.</p>\n<p>Jest 외에 다른 테스트 프레임워크\nMocha\nMocha는 Node.js와 브라우저에서 실행되는 기능이 풍부한 자바스크립트 테스트 프레임워크입니다. 비동기식 테스트를 간단하게 진행할 수 있습니다.</p>\n<p>또한 Mocha 테스트는 연속적으로 실행되어 유연하고 정확한 보고를 가능하게 하는 동시에 미검증 예외를 올바른 테스트 사례에 Mapping 합니다.</p>\n<p>Mocha는 확장성이 좋다고 알려져 있는데, 이것은 여러가지 라이브러리를 사용해서 기능을 확장시킬 수 있다는 의미입니다. Mocha의 경우 Assertion은 Chai를 사용하고, 테스트 더블은 주로 Sinon을 사용합니다.</p>\n<p>Jasmine\nJasmine은 자바스크립트 코드를 테스트하기 위한 동작 중심 개발 프레임워크입니다. Jasmine은 다른 Javascript 프레임워크에 의존하지 않으며, DOM이 필요하지 않습니다.</p>\n<p>구문 자체가 꺠끗하고 명확한 구문을 가지고 있어서 쉽게 시험을 작성할 수 있습니다.</p>\n<p>대표적인 사용사례는 Karma와 Jasmine의 조합으로 사용되는데, 이는 브라우징 테스트가 필요할 떄 사용합니다. 이는 Node.js와 브라우저 환경 모두에서 사용이 가능하기 때문 입니다.</p>\n<p>Mocha와의 차이점은 여러가지 라이브러리를 사용해야 했지만 Jasmine은 모든 기능을 통합해서 제공하기 때문에 추가적인 라이브러리가 필요 없습니다.</p>\n<p>Puppeteer\nPuppeteer는 Chromium이 포함되어 있고, 기본적으로 “Head가 없는” 상태로 실행됩니다. 여기서 Head가 없는 브라우저란 쉽게 말해 Headless browser 는 UI 없이 간편하게 백그라운드에서 실행되는 브라우저입니다. 실제로 브라우저 창을 띄우지 않고 백그라운드에서 가상으로 진행되며, 특정 페이지에 접속하고 렌더링 되는 과정 후 수행하고자 하는 코드를 수행하는데 용이합니다. 예를 들면 GUI가 없는 Ubuntu 서버 환경에서 용이할 수 있을 것입니다.</p>\n<p>이는 곧 CLI에서 작동하는 브라우저라고도 할 수 있는데, 백그라운드에서 작동한다는 것 외에 일반적인 브라우저와 같은 방식의 렌더링을 사용합니다. 하지만 만든 화면을 사용자에게 보여주지는 않습니다.</p>\n<p>브라우저 상에서 할 수 있는 것들은 대부분 Puppteer로 할 수 있습니다. 예를 들면, 스크린샷을 찍어 PDF로 만들거나, SPA로 되어 있는 페이지를 크롤링하거나, UI 테스트, 키보드 입력 자동화, 최신 버전의 크롬 브라우저 환경에서의 테스트 등 매우 다양합니다.</p>\n<p>[Testing] 테스트의 종류 및 Jest\nsms8377·2021년 5월 6일\njesttesting\n2</p>\n<p>유닛 테스트, 통합 테스트, 기능 테스트\n유닛 테스트 : 코드가 제대로 작동하는지 확인하기 위해 애플리케이션의 개별 모듈을 독립적으로 테스트(종속성과의 상호 작용없이)하는 것을 의미합니다.\n통합 테스트 : 다른 모듈이 그룹으로 결합될 때 잘 작동하는지 확인하는 것을 의미합니다.\n기능 테스트 : 시스템의 기능 조각(종속성과 상호 작용 할 수 있음)을 테스트하여 코드가 올바른 작업을 수행하는지 확인하는 것을 의미합니다.\n기능 테스트는 통합 테스트와 관련이 있지만, 모든 코드가 함께 실행되는 상태에서 전체 애플리케이션의 기능을 확인하는 테스트를 의미합니다.</p>\n<p>단위 테스트는 시슽메의 단일 구성 요소 검사를 고려하는 반면, 기능 테스트는 시스템 요구 사항 사양에 설명 되어 있는 의도 된 기능에 대해 응용 프로그램 작동을 검사하는 것 입니다.</p>\n<p>유닛 테스트의 특징\n가장 작은 단위의 테스트이며, 보통 메서드 레벨입니다.\nA라는 함수가 실행되면 B라는 결과가 나온다 정도로 테스트합니다.\n즉각적인 피드백이 나온다는 것이 훌륭한 장점입니다.\n꼭 메모리 내에서만 실행되는 테스트여야 한다는 법칙은 없습니다.\nDB, Network Access, File System 등을 사용하여도 단위테스트의 레벨일 수 있습니다.\n하나의 메서드들이 잘 동작한다는 것은 보장할 수 있지만, 그들이 결합되었을 때도 잘 작동한다는 것은 보장할 수 없습니다.\n테스트하기 어려운 부분은 stub을 사용하여 테스트합니다.\n비용이 크지 않다면 stub 보다는 실제 객체를 사용하는 것이 좋습니다.\n아무래도 정교한 목 객체가 실제 객체보다 정확하지는 않기 때문입니다.\n모든 것은 비용 관점에서 생각해야 합니다.\nE2E 테스트의 특징\n해당 시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 시험하는 것을 말합니다.\n용어를 사용하는 곳마다 조금씩 차이가 있다고 합니다.\n내부 기능들까지(클래스의 메서드) 테스트 할 필요는 없습니다.\n이는 단위테스트의 영역입니다.\n단점은 테스트를 만들기가 힘들고, 만든 테스트를 신뢰하기도 힘들다는 것입니다.\n통합 테스트의 특징\n모듈을 통합하는 과정에서 모듈 간 호환성의 문제를 찾아내기 위해 수행되는 테스트입니다.\n유닛 테스트와의 차이점은 유닛 테스트는 다른 컴포넌트들과 도긻적인 반면 통합 테스트는 그렇지 않습니다.\n예를 들면, 유닛 테스트에서 데이터베이스에 접근하는 코드는 실제 데이터 베이스와 통신하는 것은 아니지만, 통합 테스트는 실제 통신해야 합니다.\n통합 테스트는 대게 유닛 테스트를 작성하는 것보다 복잡하고 오랜 시간이 걸립니다.\n꼭 필요한 것이 아니라면, 유닛 테스트를 작성하는데 집중하는 것이 좋습니다.\nStub과 Mock의 개념\nStub\nstub은 아직 준비되지 못한 코드를 미리 정해진 답변으로 반환할 수 있도록 하는 메커니즘입니다. 가짜 객체가 실제로 동작하는 것처럼 보이게 만들어놓은 객체이며, 호출자를 실제 구현물로부터 격리시켜 독립적인 테스트를 진행할 수 있도록 하는 것이 Stub입니다.</p>\n<p>Stub은 아래와 같은 경우 주로 사용 됩니다.</p>\n<p>복잡한 로직을 단순화 하고 싶을 떄\n구현이 되지 않은 함수가 있을 때\n라이브러리에서 제공하는 함수를 사용하고자 할 때\n의존성을 가지는 유닛의 응답을 모사하여 독립적인 테스트를 수행하고자 할 때\nMock\nMock은 가짜라는 의미인데, 이 Mock 이 사용되는 부분은 Mocking이라는 작업을 할 떄 사용됩니다.</p>\n<p>Mocking이란, 유닛 테스트 등을 작성할 때 해당 코드가 의존성을 가지고 있다면 그 의존하는 부분을 가짜로 대체하는 기법입니다. 일반적으로 유닛 테스트의 해당 코드가 의존하는 부분을 직접 생성하는 것이 까다로울 때 Mocking을 많이 사용합니다.</p>\n<p>Jest는 어떤 일을 하며 어떻게 사용하는 테스트 프레임워크일까요?</p>\n<p>Jest 이외의 테스트 프레임워크는 어떤 것이 있고 어떤 장단점이 있을까요?\nJest란?\nJest란 단순함에 초점을 둔 페이스북에서 개발한 오픈 소스 자바스크립트 테스트 프레임워크입니다. 비교적 사용이 간단하며 Babel, Typescript 등에 모두 사용할 수 있습니다.</p>\n<p>Jest는 테스트가 전역 상태를 갖도록 하여 모든 테스트를 평행적으로 수행이 가능하게 합니다. 또한 빠른 테스트를 위해 이전 테스트에서 실패했던 것을 가장 먼저 실행하고, 테스트의 수행 시간을 예측하여 실행 순서를 재배치합니다.</p>\n<p>테스트의 코드 커버리지를 파악할 땐 —coverage Flag를 통해 간단하게 파악할 수 있습니다.</p>\n<p>Jest 외에 다른 테스트 프레임워크\nMocha\nMocha는 Node.js와 브라우저에서 실행되는 기능이 풍부한 자바스크립트 테스트 프레임워크입니다. 비동기식 테스트를 간단하게 진행할 수 있습니다.</p>\n<p>또한 Mocha 테스트는 연속적으로 실행되어 유연하고 정확한 보고를 가능하게 하는 동시에 미검증 예외를 올바른 테스트 사례에 Mapping 합니다.</p>\n<p>Mocha는 확장성이 좋다고 알려져 있는데, 이것은 여러가지 라이브러리를 사용해서 기능을 확장시킬 수 있다는 의미입니다. Mocha의 경우 Assertion은 Chai를 사용하고, 테스트 더블은 주로 Sinon을 사용합니다.</p>\n<p>Jasmine\nJasmine은 자바스크립트 코드를 테스트하기 위한 동작 중심 개발 프레임워크입니다. Jasmine은 다른 Javascript 프레임워크에 의존하지 않으며, DOM이 필요하지 않습니다.</p>\n<p>구문 자체가 꺠끗하고 명확한 구문을 가지고 있어서 쉽게 시험을 작성할 수 있습니다.</p>\n<p>대표적인 사용사례는 Karma와 Jasmine의 조합으로 사용되는데, 이는 브라우징 테스트가 필요할 떄 사용합니다. 이는 Node.js와 브라우저 환경 모두에서 사용이 가능하기 때문 입니다.</p>\n<p>Mocha와의 차이점은 여러가지 라이브러리를 사용해야 했지만 Jasmine은 모든 기능을 통합해서 제공하기 때문에 추가적인 라이브러리가 필요 없습니다.</p>\n<p>Puppeteer\nPuppeteer는 Chromium이 포함되어 있고, 기본적으로 “Head가 없는” 상태로 실행됩니다. 여기서 Head가 없는 브라우저란 쉽게 말해 Headless browser 는 UI 없이 간편하게 백그라운드에서 실행되는 브라우저입니다. 실제로 브라우저 창을 띄우지 않고 백그라운드에서 가상으로 진행되며, 특정 페이지에 접속하고 렌더링 되는 과정 후 수행하고자 하는 코드를 수행하는데 용이합니다. 예를 들면 GUI가 없는 Ubuntu 서버 환경에서 용이할 수 있을 것입니다.</p>\n<p>이는 곧 CLI에서 작동하는 브라우저라고도 할 수 있는데, 백그라운드에서 작동한다는 것 외에 일반적인 브라우저와 같은 방식의 렌더링을 사용합니다. 하지만 만든 화면을 사용자에게 보여주지는 않습니다.</p>\n<p>브라우저 상에서 할 수 있는 것들은 대부분 Puppteer로 할 수 있습니다. 예를 들면, 스크린샷을 찍어 PDF로 만들거나, SPA로 되어 있는 페이지를 크롤링하거나, UI 테스트, 키보드 입력 자동화, 최신 버전의 크롬 브라우저 환경에서의 테스트 등 매우 다양합니다.</p>\n<p>[Testing] 테스트의 종류 및 Jest\nsms8377·2021년 5월 6일\njesttesting\n2</p>\n<p>유닛 테스트, 통합 테스트, 기능 테스트\n유닛 테스트 : 코드가 제대로 작동하는지 확인하기 위해 애플리케이션의 개별 모듈을 독립적으로 테스트(종속성과의 상호 작용없이)하는 것을 의미합니다.\n통합 테스트 : 다른 모듈이 그룹으로 결합될 때 잘 작동하는지 확인하는 것을 의미합니다.\n기능 테스트 : 시스템의 기능 조각(종속성과 상호 작용 할 수 있음)을 테스트하여 코드가 올바른 작업을 수행하는지 확인하는 것을 의미합니다.\n기능 테스트는 통합 테스트와 관련이 있지만, 모든 코드가 함께 실행되는 상태에서 전체 애플리케이션의 기능을 확인하는 테스트를 의미합니다.</p>\n<p>단위 테스트는 시슽메의 단일 구성 요소 검사를 고려하는 반면, 기능 테스트는 시스템 요구 사항 사양에 설명 되어 있는 의도 된 기능에 대해 응용 프로그램 작동을 검사하는 것 입니다.</p>\n<p>유닛 테스트의 특징\n가장 작은 단위의 테스트이며, 보통 메서드 레벨입니다.\nA라는 함수가 실행되면 B라는 결과가 나온다 정도로 테스트합니다.\n즉각적인 피드백이 나온다는 것이 훌륭한 장점입니다.\n꼭 메모리 내에서만 실행되는 테스트여야 한다는 법칙은 없습니다.\nDB, Network Access, File System 등을 사용하여도 단위테스트의 레벨일 수 있습니다.\n하나의 메서드들이 잘 동작한다는 것은 보장할 수 있지만, 그들이 결합되었을 때도 잘 작동한다는 것은 보장할 수 없습니다.\n테스트하기 어려운 부분은 stub을 사용하여 테스트합니다.\n비용이 크지 않다면 stub 보다는 실제 객체를 사용하는 것이 좋습니다.\n아무래도 정교한 목 객체가 실제 객체보다 정확하지는 않기 때문입니다.\n모든 것은 비용 관점에서 생각해야 합니다.\nE2E 테스트의 특징\n해당 시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 시험하는 것을 말합니다.\n용어를 사용하는 곳마다 조금씩 차이가 있다고 합니다.\n내부 기능들까지(클래스의 메서드) 테스트 할 필요는 없습니다.\n이는 단위테스트의 영역입니다.\n단점은 테스트를 만들기가 힘들고, 만든 테스트를 신뢰하기도 힘들다는 것입니다.\n통합 테스트의 특징\n모듈을 통합하는 과정에서 모듈 간 호환성의 문제를 찾아내기 위해 수행되는 테스트입니다.\n유닛 테스트와의 차이점은 유닛 테스트는 다른 컴포넌트들과 도긻적인 반면 통합 테스트는 그렇지 않습니다.\n예를 들면, 유닛 테스트에서 데이터베이스에 접근하는 코드는 실제 데이터 베이스와 통신하는 것은 아니지만, 통합 테스트는 실제 통신해야 합니다.\n통합 테스트는 대게 유닛 테스트를 작성하는 것보다 복잡하고 오랜 시간이 걸립니다.\n꼭 필요한 것이 아니라면, 유닛 테스트를 작성하는데 집중하는 것이 좋습니다.\nStub과 Mock의 개념\nStub\nstub은 아직 준비되지 못한 코드를 미리 정해진 답변으로 반환할 수 있도록 하는 메커니즘입니다. 가짜 객체가 실제로 동작하는 것처럼 보이게 만들어놓은 객체이며, 호출자를 실제 구현물로부터 격리시켜 독립적인 테스트를 진행할 수 있도록 하는 것이 Stub입니다.</p>\n<p>Stub은 아래와 같은 경우 주로 사용 됩니다.</p>\n<p>복잡한 로직을 단순화 하고 싶을 떄\n구현이 되지 않은 함수가 있을 때\n라이브러리에서 제공하는 함수를 사용하고자 할 때\n의존성을 가지는 유닛의 응답을 모사하여 독립적인 테스트를 수행하고자 할 때\nMock\nMock은 가짜라는 의미인데, 이 Mock 이 사용되는 부분은 Mocking이라는 작업을 할 떄 사용됩니다.</p>\n<p>Mocking이란, 유닛 테스트 등을 작성할 때 해당 코드가 의존성을 가지고 있다면 그 의존하는 부분을 가짜로 대체하는 기법입니다. 일반적으로 유닛 테스트의 해당 코드가 의존하는 부분을 직접 생성하는 것이 까다로울 때 Mocking을 많이 사용합니다.</p>\n<p>Jest는 어떤 일을 하며 어떻게 사용하는 테스트 프레임워크일까요?</p>\n<p>Jest 이외의 테스트 프레임워크는 어떤 것이 있고 어떤 장단점이 있을까요?\nJest란?\nJest란 단순함에 초점을 둔 페이스북에서 개발한 오픈 소스 자바스크립트 테스트 프레임워크입니다. 비교적 사용이 간단하며 Babel, Typescript 등에 모두 사용할 수 있습니다.</p>\n<p>Jest는 테스트가 전역 상태를 갖도록 하여 모든 테스트를 평행적으로 수행이 가능하게 합니다. 또한 빠른 테스트를 위해 이전 테스트에서 실패했던 것을 가장 먼저 실행하고, 테스트의 수행 시간을 예측하여 실행 순서를 재배치합니다.</p>\n<p>테스트의 코드 커버리지를 파악할 땐 —coverage Flag를 통해 간단하게 파악할 수 있습니다.</p>\n<p>Jest 외에 다른 테스트 프레임워크\nMocha\nMocha는 Node.js와 브라우저에서 실행되는 기능이 풍부한 자바스크립트 테스트 프레임워크입니다. 비동기식 테스트를 간단하게 진행할 수 있습니다.</p>\n<p>또한 Mocha 테스트는 연속적으로 실행되어 유연하고 정확한 보고를 가능하게 하는 동시에 미검증 예외를 올바른 테스트 사례에 Mapping 합니다.</p>\n<p>Mocha는 확장성이 좋다고 알려져 있는데, 이것은 여러가지 라이브러리를 사용해서 기능을 확장시킬 수 있다는 의미입니다. Mocha의 경우 Assertion은 Chai를 사용하고, 테스트 더블은 주로 Sinon을 사용합니다.</p>\n<p>Jasmine\nJasmine은 자바스크립트 코드를 테스트하기 위한 동작 중심 개발 프레임워크입니다. Jasmine은 다른 Javascript 프레임워크에 의존하지 않으며, DOM이 필요하지 않습니다.</p>\n<p>구문 자체가 꺠끗하고 명확한 구문을 가지고 있어서 쉽게 시험을 작성할 수 있습니다.</p>\n<p>대표적인 사용사례는 Karma와 Jasmine의 조합으로 사용되는데, 이는 브라우징 테스트가 필요할 떄 사용합니다. 이는 Node.js와 브라우저 환경 모두에서 사용이 가능하기 때문 입니다.</p>\n<p>Mocha와의 차이점은 여러가지 라이브러리를 사용해야 했지만 Jasmine은 모든 기능을 통합해서 제공하기 때문에 추가적인 라이브러리가 필요 없습니다.</p>\n<p>Puppeteer\nPuppeteer는 Chromium이 포함되어 있고, 기본적으로 “Head가 없는” 상태로 실행됩니다. 여기서 Head가 없는 브라우저란 쉽게 말해 Headless browser 는 UI 없이 간편하게 백그라운드에서 실행되는 브라우저입니다. 실제로 브라우저 창을 띄우지 않고 백그라운드에서 가상으로 진행되며, 특정 페이지에 접속하고 렌더링 되는 과정 후 수행하고자 하는 코드를 수행하는데 용이합니다. 예를 들면 GUI가 없는 Ubuntu 서버 환경에서 용이할 수 있을 것입니다.</p>\n<p>이는 곧 CLI에서 작동하는 브라우저라고도 할 수 있는데, 백그라운드에서 작동한다는 것 외에 일반적인 브라우저와 같은 방식의 렌더링을 사용합니다. 하지만 만든 화면을 사용자에게 보여주지는 않습니다.</p>\n<p>브라우저 상에서 할 수 있는 것들은 대부분 Puppteer로 할 수 있습니다. 예를 들면, 스크린샷을 찍어 PDF로 만들거나, SPA로 되어 있는 페이지를 크롤링하거나, UI 테스트, 키보드 입력 자동화, 최신 버전의 크롬 브라우저 환경에서의 테스트 등 매우 다양합니다.</p>\n<p>Reference\n<a href=\"https://velog.io/@sms8377/Testing-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A2%85%EB%A5%98-%EB%B0%8F-Jest\">sms9377님 블로그</a></p>\n<h2 id=\"redux-saga-로-프로미스-다루기\" style=\"position:relative;\"><a href=\"#redux-saga-%EB%A1%9C-%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4-%EB%8B%A4%EB%A3%A8%EA%B8%B0\" aria-label=\"redux saga 로 프로미스 다루기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>redux-saga 로 프로미스 다루기</strong></h2>\n<p>이번에는 redux-saga를 사용하여 프로미스를 다루는 방법을 배워보도록 하겠습니다. 우리가 이전에 redux-thunk를 배울 때에는 thunk함수를 만들어서 이 함수가 디스패치 될 때 비동기 작업을 처리하고, 액션 객체를 디스패치하거나 스토어의 현재 상태를 조회 할 수도 있죠.</p>\n<p>redux-thunk를 배울 때 사용했던 thunk 함수를 다시 한번 확인해볼까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const getPosts = () => async dispatch => {\n  dispatch({ type: GET_POSTS }); // 요청이 시작됨\n  try {\n    const posts = postsAPI.getPosts(); // API 호출\n    dispatch({ type: GET_POSTS_SUCCESS, posts }); // 성공\n  } catch (e) {\n    dispatch({ type: GET_POSTS_ERROR, error: e }); // 실패\n  }\n};</code></pre></div>\n<p>redux-thunk에서는 이렇게 함수를 만들어서 해당 함수에서 비동기 작업을 하고 필요한 시점에 특정 액션을 디스패치합니다. redux-saga는 비동기 작업을 처리 할 때 다른 방식으로 처리합니다.</p>\n<p>redux-saga에서는 특정 액션을 모니터링하도록 하고, 해당 액션이 주어지면 이에 따라 제너레이터 함수를 실행하여 비동기 작업을 처리 후 액션을 디스패치합니다.</p>\n<p>기존에 redux-thunk로 구현했던 posts 모듈을 redux-saga로 구현해봅시다.</p>\n<h3 id=\"modulespostsjs\" style=\"position:relative;\"><a href=\"#modulespostsjs\" aria-label=\"modulespostsjs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>modules/posts.js</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import * as postsAPI from '../api/posts'; // api/posts 안의 함수 모두 불러오기\nimport {\n  reducerUtils,\n  handleAsyncActions,\n  handleAsyncActionsById\n} from '../lib/asyncUtils';\nimport { call, put, takeEvery } from 'redux-saga/effects';\n\n/* 액션 타입 */\n\n// 포스트 여러개 조회하기\nconst GET_POSTS = 'GET_POSTS'; // 요청 시작\nconst GET_POSTS_SUCCESS = 'GET_POSTS_SUCCESS'; // 요청 성공\nconst GET_POSTS_ERROR = 'GET_POSTS_ERROR'; // 요청 실패\n\n// 포스트 하나 조회하기\nconst GET_POST = 'GET_POST';\nconst GET_POST_SUCCESS = 'GET_POST_SUCCESS';\nconst GET_POST_ERROR = 'GET_POST_ERROR';\n\nexport const getPosts = () => ({ type: GET_POSTS });\n// payload는 파라미터 용도, meta는 리듀서에서 id를 알기위한 용도\nexport const getPost = id => ({ type: GET_POST, payload: id, meta: id });\n\nfunction* getPostsSaga() {\n  try {\n    const posts = yield call(postsAPI.getPosts); // call 을 사용하면 특정 함수를 호출하고, 결과물이 반환 될 때까지 기다려줄 수 있습니다.\n    yield put({\n      type: GET_POSTS_SUCCESS,\n      payload: posts\n    }); // 성공 액션 디스패치\n  } catch (e) {\n    yield put({\n      type: GET_POSTS_ERROR,\n      error: true,\n      payload: e\n    }); // 실패 액션 디스패치\n  }\n}\n\n// 액션이 지니고 있는 값을 조회하고 싶다면 action을 파라미터로 받아와서 사용 할 수 있습니다.\nfunction* getPostSaga(action) {\n  const param = action.payload;\n  const id = action.meta;\n  try {\n    const post = yield call(postsAPI.getPostById, param); // API 함수에 넣어주고 싶은 인자는 call 함수의 두번째 인자부터 순서대로 넣어주면 됩니다.\n    yield put({\n      type: GET_POST_SUCCESS,\n      payload: post,\n      meta: id\n    });\n  } catch (e) {\n    yield put({\n      type: GET_POST_ERROR,\n      error: true,\n      payload: e,\n      meta: id\n    });\n  }\n}\n\n// 사가들을 합치기\nexport function* postsSaga() {\n  yield takeEvery(GET_POSTS, getPostsSaga);\n  yield takeEvery(GET_POST, getPostSaga);\n}\n\n// 3번째 인자를 사용하면 withExtraArgument 에서 넣어준 값들을 사용 할 수 있습니다.\nexport const goToHome = () => (dispatch, getState, { history }) => {\n  history.push('/');\n};\n\n// initialState 쪽도 반복되는 코드를 initial() 함수를 사용해서 리팩토링 했습니다.\nconst initialState = {\n  posts: reducerUtils.initial(),\n  post: reducerUtils.initial()\n};\n\nexport default function posts(state = initialState, action) {\n  switch (action.type) {\n    case GET_POSTS:\n    case GET_POSTS_SUCCESS:\n    case GET_POSTS_ERROR:\n      return handleAsyncActions(GET_POSTS, 'posts', true)(state, action);\n    case GET_POST:\n    case GET_POST_SUCCESS:\n    case GET_POST_ERROR:\n      return handleAsyncActionsById(GET_POST, 'post', true)(state, action);\n    default:\n      return state;\n  }\n}</code></pre></div>\n<blockquote>\n<p>기존 redux-thunk 튜토리얼을 생략하고 바로 이 튜토리얼로 오신 분들을 위해 미리 설명 드리자면, 여기서 사용된 asyncUtils.js 는 여기에서 확인 할 수 있습니다.</p>\n</blockquote>\n<p>기존에 redux-thunk로 구현 할 때에는 <code class=\"language-text\">getPosts</code> 와 <code class=\"language-text\">getPost</code> 는 thunk 함수였는데, 이제는 redux-saga를 사용하니까 순수 액션 객체를 반환하는 액션 생성 함수로 구현 할 수 있습니다.</p>\n<p>액션을 모니터링해서 특정 액션이 발생했을 때 호출할 사가 함수에서는 파라미터로 해당 액션을 받아올 수 있습니다. 그래서 <code class=\"language-text\">getPostSaga</code>의 경우엔 액션을 파라미터로 받아와서 해당 액션의 <code class=\"language-text\">id</code> 값을 참조 할 수 있죠.</p>\n<p>예를 들어서, <code class=\"language-text\">dispatch({ type: GET_POST, payload: 1, meta: 1 })</code>이란 코드가 실행 되면 액션에서 <code class=\"language-text\">action.payload</code>값을 추출하여 API를 호출 할 때 인자로 넣어서 호출하는 것 입니다. 여기서 <code class=\"language-text\">meta</code> 값이 있는 이유는 우리가 이전에 만들었던 <code class=\"language-text\">handleAsyncActionsById</code> 를 호환시키기 위함입니다. 만약 <code class=\"language-text\">handleAsyncActionsById</code>를 사용하지 않는다면 <code class=\"language-text\">meta</code> 를 생략하셔도 됩니다. 그리고 추후 우리가 리팩토링 과정에서 프로미스를 처리하는 사가 함수를 쉽게 만드는 함수를 만들건데요, 만약에 리팩토링을 하지 않을거라면 사실상 <code class=\"language-text\">{ type: GET_POST, id }</code> 이런식으로 파라미터를 꼭 <code class=\"language-text\">payload</code> 라고 설정 할 필요는 없습니다.</p>\n<p>코드를 다 작성하셨다면 rootSaga에 우리가 방금 만든 postsSaga를 등록해주세요.</p>\n<h3 id=\"code-classlanguage-textmodulesindexjscode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textmodulesindexjscode\" aria-label=\"code classlanguage textmodulesindexjscode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong><code class=\"language-text\">modules/index.js</code></strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { combineReducers } from 'redux';\nimport counter, { counterSaga } from './counter';\nimport posts, { postsSaga } from './posts';\nimport { all } from 'redux-saga/effects';\n\nconst rootReducer = combineReducers({ counter, posts });\nexport function* rootSaga() {\n  yield all([counterSaga(), postsSaga()]); // all 은 배열 안의 여러 사가를 동시에 실행시켜줍니다.\n}\n\nexport default rootReducer;</code></pre></div>\n<p>이제 기존의 컨테이너 컴포넌트들이 잘 작동하는지 확인해보세요. redux-saga를 사용하면 이렇게 순수 액션 객체만을 디스패치해서 비동기 작업을 처리 할 수 있게 됩니다.</p>\n<blockquote>\n<p>지금까지의 코드는 여기서 확인 할 수 있습니다.</p>\n</blockquote>\n<h3 id=\"프로미스를-처리하는-사가-리팩토링\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4%EB%A5%BC-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EC%82%AC%EA%B0%80-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81\" aria-label=\"프로미스를 처리하는 사가 리팩토링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>프로미스를 처리하는 사가 리팩토링</strong></h3>\n<p>기존에 우리가 작성했던 사가함수들을 다시 확인해봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function* getPostsSaga() {\n  try {\n    const posts = yield call(postsAPI.getPosts); // call 을 사용하면 특정 함수를 호출하고, 결과물이 반환 될 때까지 기다려줄 수 있습니다.\n    yield put({\n      type: GET_POSTS_SUCCESS,\n      payload: posts\n    }); // 성공 액션 디스패치\n  } catch (e) {\n    yield put({\n      type: GET_POSTS_ERROR,\n      error: true,\n      payload: e\n    }); // 실패 액션 디스패치\n  }\n}\n\n// 액션이 지니고 있는 값을 조회하고 싶다면 action을 파라미터로 받아와서 사용 할 수 있습니다.\nfunction* getPostSaga(action) {\n  const param = action.payload;\n  const id = action.meta;\n  try {\n    const post = yield call(postsAPI.getPostById, param); // API 함수에 넣어주고 싶은 인자는 call 함수의 두번째 인자부터 순서대로 넣어주면 됩니다.\n    yield put({\n      type: GET_POST_SUCCESS,\n      payload: post,\n      meta: id\n    });\n  } catch (e) {\n    yield put({\n      type: GET_POST_ERROR,\n      error: true,\n      payload: e,\n      meta: id\n    });\n  }\n}</code></pre></div>\n<p>우리가 까다로운 사가 함수를 만들게 될 때에는 사가 함수 안에서 여러 종류의 비동기 작업을 할 수 있습니다. 하지만, 우리가 방금 만든 기능 처럼 단순히 하나의 API를 요청해서 결과물을 가지고 액션을 디스패치 하는일이 꽤나 많이 발생하기도 합니다.</p>\n<p>까다로운 작업을 할 때에는 사가 함수를 직접 작성하고, 지금처럼 간단한 비동기 작업을 처리 할 때에는 우리가 이전에 redux-thunk를 배울 때 <code class=\"language-text\">createPromiseThunk</code>, <code class=\"language-text\">createPromiseThunkById</code> 를 만들어서 사용했던 것 처럼 비슷한 방식으로 반복되는 로직들을 함수화 하여 재사용하면 훨씬 깔끔한 코드로 작성을 할 수 있고, 생산성도 높일 수 있습니다.</p>\n<p>그럼, <code class=\"language-text\">createPromiseSaga</code>와 <code class=\"language-text\">createPromiseSagaById</code>를 작성해보도록 하겠습니다.</p>\n<p>기존 <code class=\"language-text\">createPromiseThunk</code>, <code class=\"language-text\">createPromiseSaga</code> 는 지우도록 하겠습니다(원하시면 유지하시거나 주석처리만 하셔도 좋습니다). 참고로 <code class=\"language-text\">handleAsyncActions</code> 와 <code class=\"language-text\">handleAsyncActionsById</code>는 변동사항 없습니다.</p>\n<h3 id=\"libasyncutilsjs\" style=\"position:relative;\"><a href=\"#libasyncutilsjs\" aria-label=\"libasyncutilsjs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>lib/asyncUtils.js</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { call, put } from 'redux-saga/effects';\n\n// 프로미스를 기다렸다가 결과를 디스패치하는 사가\nexport const createPromiseSaga = (type, promiseCreator) => {\n  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n  return function* saga(action) {\n    try {\n      // 재사용성을 위하여 promiseCreator 의 파라미터엔 action.payload 값을 넣도록 설정합니다.\n      const payload = yield call(promiseCreator, action.payload);\n      yield put({ type: SUCCESS, payload });\n    } catch (e) {\n      yield put({ type: ERROR, error: true, payload: e });\n    }\n  };\n};\n\n// 특정 id의 데이터를 조회하는 용도로 사용하는 사가\n// API를 호출 할 때 파라미터는 action.payload를 넣고,\n// id 값을 action.meta로 설정합니다.\nexport const createPromiseSagaById = (type, promiseCreator) => {\n  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n  return function* saga(action) {\n    const id = action.meta;\n    try {\n      const payload = yield call(promiseCreator, action.payload);\n      yield put({ type: SUCCESS, payload, meta: id });\n    } catch (e) {\n      yield put({ type: ERROR, error: e, meta: id });\n    }\n  };\n};\n\n// 리듀서에서 사용 할 수 있는 여러 유틸 함수들입니다.\nexport const reducerUtils = {\n  // 초기 상태. 초기 data 값은 기본적으로 null 이지만\n  // 바꿀 수도 있습니다.\n  initial: (initialData = null) => ({\n    loading: false,\n    data: initialData,\n    error: null\n  }),\n  // 로딩중 상태. prevState의 경우엔 기본값은 null 이지만\n  // 따로 값을 지정하면 null 로 바꾸지 않고 다른 값을 유지시킬 수 있습니다.\n  loading: (prevState = null) => ({\n    loading: true,\n    data: prevState,\n    error: null\n  }),\n  // 성공 상태\n  success: payload => ({\n    loading: false,\n    data: payload,\n    error: null\n  }),\n  // 실패 상태\n  error: error => ({\n    loading: false,\n    data: null,\n    error: error\n  })\n};\n\n// 비동기 관련 액션들을 처리하는 리듀서를 만들어줍니다.\n// type 은 액션의 타입, key 는 상태의 key (예: posts, post) 입니다.\nexport const handleAsyncActions = (type, key, keepData = false) => {\n  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n  return (state, action) => {\n    switch (action.type) {\n      case type:\n        return {\n          ...state,\n          [key]: reducerUtils.loading(keepData ? state[key].data : null)\n        };\n      case SUCCESS:\n        return {\n          ...state,\n          [key]: reducerUtils.success(action.payload)\n        };\n      case ERROR:\n        return {\n          ...state,\n          [key]: reducerUtils.error(action.payload)\n        };\n      default:\n        return state;\n    }\n  };\n};\n\n// id별로 처리하는 유틸함수\nexport const handleAsyncActionsById = (type, key, keepData = false) => {\n  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];\n  return (state, action) => {\n    const id = action.meta;\n    switch (action.type) {\n      case type:\n        return {\n          ...state,\n          [key]: {\n            ...state[key],\n            [id]: reducerUtils.loading(\n              // state[key][id]가 만들어져있지 않을 수도 있으니까 유효성을 먼저 검사 후 data 조회\n              keepData ? state[key][id] &amp;&amp; state[key][id].data : null\n            )\n          }\n        };\n      case SUCCESS:\n        return {\n          ...state,\n          [key]: {\n            ...state[key],\n            [id]: reducerUtils.success(action.payload)\n          }\n        };\n      case ERROR:\n        return {\n          ...state,\n          [key]: {\n            ...state[key],\n            [id]: reducerUtils.error(action.payload)\n          }\n        };\n      default:\n        return state;\n    }\n  };\n};</code></pre></div>\n<p>이제 사가를 통해 비동기 작업을 처리 할 때에는 API 함수의 인자는 액션에서부터 참조합니다. 액션 객체에서 사용 할 함수의 인자의 이름은 <code class=\"language-text\">payload</code> 로 통일 시키도록 하겠습니다. 그리고, 특정 id를 위한 비동기작업을 처리하는 <code class=\"language-text\">createPromiseSagaById</code>와 <code class=\"language-text\">handleAsyncActionsById</code>에서는 id 값을 <code class=\"language-text\">action.meta</code> 에서 참조하도록 하겠습니다.</p>\n<h3 id=\"modulespostsjs-1\" style=\"position:relative;\"><a href=\"#modulespostsjs-1\" aria-label=\"modulespostsjs 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>modules/posts.js</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import * as postsAPI from '../api/posts'; // api/posts 안의 함수 모두 불러오기\nimport {\n  reducerUtils,\n  handleAsyncActions,\n  handleAsyncActionsById,\n  createPromiseSaga,\n  createPromiseSagaById\n} from '../lib/asyncUtils';\nimport { takeEvery } from 'redux-saga/effects';\n\n/* 액션 타입 */\n\n// 포스트 여러개 조회하기\nconst GET_POSTS = 'GET_POSTS'; // 요청 시작\nconst GET_POSTS_SUCCESS = 'GET_POSTS_SUCCESS'; // 요청 성공\nconst GET_POSTS_ERROR = 'GET_POSTS_ERROR'; // 요청 실패\n\n// 포스트 하나 조회하기\nconst GET_POST = 'GET_POST';\nconst GET_POST_SUCCESS = 'GET_POST_SUCCESS';\nconst GET_POST_ERROR = 'GET_POST_ERROR';\n\nexport const getPosts = () => ({ type: GET_POSTS });\nexport const getPost = id => ({ type: GET_POST, payload: id, meta: id });\n\nconst getPostsSaga = createPromiseSaga(GET_POSTS, postsAPI.getPosts);\nconst getPostSaga = createPromiseSagaById(GET_POST, postsAPI.getPostById);\n\n// 사가들을 합치기\nexport function* postsSaga() {\n  yield takeEvery(GET_POSTS, getPostsSaga);\n  yield takeEvery(GET_POST, getPostSaga);\n}\n\n// 3번째 인자를 사용하면 withExtraArgument 에서 넣어준 값들을 사용 할 수 있습니다.\nexport const goToHome = () => (dispatch, getState, { history }) => {\n  history.push('/');\n};\n\n// initialState 쪽도 반복되는 코드를 initial() 함수를 사용해서 리팩토링 했습니다.\nconst initialState = {\n  posts: reducerUtils.initial(),\n  post: reducerUtils.initial()\n};\n\nexport default function posts(state = initialState, action) {\n  switch (action.type) {\n    case GET_POSTS:\n    case GET_POSTS_SUCCESS:\n    case GET_POSTS_ERROR:\n      return handleAsyncActions(GET_POSTS, 'posts', true)(state, action);\n    case GET_POST:\n    case GET_POST_SUCCESS:\n    case GET_POST_ERROR:\n      return handleAsyncActionsById(GET_POST, 'post', true)(state, action);\n    default:\n      return state;\n  }\n}</code></pre></div>\n<p>코드가 훨씬 깔끔해졌지요? 매번 API 함수 호출을 위한 사가를 준비 할 때마다 사가 함수를 매번 직접 작성하는 것 보단, 간단한 로직을 가지고 있는 사가 함수의 경우 우리가 만든 유틸 함수로 새로운 사가를 손쉽게 만들어서 쓰면 굉장히 편합니다.</p>\n<h2 id=\"saga에서-라우터-연동하기\" style=\"position:relative;\"><a href=\"#saga%EC%97%90%EC%84%9C-%EB%9D%BC%EC%9A%B0%ED%84%B0-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0\" aria-label=\"saga에서 라우터 연동하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>saga에서 라우터 연동하기</strong></h2>\n<p>우리가 이전에 redux-thunk를 배울 때 thunk함수에서 리액트 라우터의 history 를 사용하는 방법을 배워보았습니다.</p>\n<p>예를 들어서 로그인 요청을 할 때 성공 할 시 특정 주소로 이동시키고, 실패 할 시엔 그대로 유지하는 기능을 구현 해야 된다면, 컨테이너 컴포넌트에서 <code class=\"language-text\">withRouter</code>를 사용해서 구현을 하는 것 보다 사가 내부에서 처리를 하는것이 훨씬 편합니다.</p>\n<p>구현 방식은 redux-thunk에서 했던 방식과 꽤나 비슷합니다. 미들웨어를 만들 때 <code class=\"language-text\">context</code>를 설정해주면 추후 사가에서 <code class=\"language-text\">getContext</code> 함수를 통해 조회 할 수 있습니다.</p>\n<h3 id=\"indexjs\" style=\"position:relative;\"><a href=\"#indexjs\" aria-label=\"indexjs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>index.js</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { createStore, applyMiddleware } from 'redux';\nimport { Provider } from 'react-redux';\nimport rootReducer, { rootSaga } from './modules';\nimport logger from 'redux-logger';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport ReduxThunk from 'redux-thunk';\nimport { Router } from 'react-router-dom';\nimport { createBrowserHistory } from 'history';\nimport createSagaMiddleware from 'redux-saga';\n\nconst customHistory = createBrowserHistory();\nconst sagaMiddleware = createSagaMiddleware({\n  context: {\n    history: customHistory\n  }\n}); // 사가 미들웨어를 만듭니다.\n\nconst store = createStore(\n  rootReducer,\n  // logger 를 사용하는 경우, logger가 가장 마지막에 와야합니다.\n  composeWithDevTools(\n    applyMiddleware(\n      ReduxThunk.withExtraArgument({ history: customHistory }),\n      sagaMiddleware, // 사가 미들웨어를 적용하고\n      logger\n    )\n  )\n); // 여러개의 미들웨어를 적용 할 수 있습니다.\n\nsagaMiddleware.run(rootSaga); // 루트 사가를 실행해줍니다.\n// 주의: 스토어 생성이 된 다음에 위 코드를 실행해야합니다.\n\nReactDOM.render(\n  &lt;Router history={customHistory}>\n    &lt;Provider store={store}>\n      &lt;App />\n    &lt;/Provider>\n  &lt;/Router>,\n  document.getElementById('root')\n);\n\nserviceWorker.unregister();</code></pre></div>\n<p>그 다음엔, <code class=\"language-text\">GOTO_HOME</code> 이라는 액션이 디스패치 되면 <code class=\"language-text\">/</code> 경로로 이동하는 기능을 사가로 구현을 해보겠습니다.</p>\n<h3 id=\"modulespostsjs-2\" style=\"position:relative;\"><a href=\"#modulespostsjs-2\" aria-label=\"modulespostsjs 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>modules/posts.js</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import * as postsAPI from '../api/posts'; // api/posts 안의 함수 모두 불러오기\nimport {\n  reducerUtils,\n  handleAsyncActions,\n  handleAsyncActionsById,\n  createPromiseSaga,\n  createPromiseSagaById\n} from '../lib/asyncUtils';\nimport { takeEvery, getContext } from 'redux-saga/effects';\n\n/* 액션 타입 */\n\n// 포스트 여러개 조회하기\nconst GET_POSTS = 'GET_POSTS'; // 요청 시작\nconst GET_POSTS_SUCCESS = 'GET_POSTS_SUCCESS'; // 요청 성공\nconst GET_POSTS_ERROR = 'GET_POSTS_ERROR'; // 요청 실패\n\n// 포스트 하나 조회하기\nconst GET_POST = 'GET_POST';\nconst GET_POST_SUCCESS = 'GET_POST_SUCCESS';\nconst GET_POST_ERROR = 'GET_POST_ERROR';\nconst GO_TO_HOME = 'GO_TO_HOME';\n\nexport const getPosts = () => ({ type: GET_POSTS });\nexport const getPost = id => ({ type: GET_POST, payload: id, meta: id });\nexport const goToHome = () => ({ type: GO_TO_HOME });\n\nconst getPostsSaga = createPromiseSaga(GET_POSTS, postsAPI.getPosts);\nconst getPostSaga = createPromiseSagaById(GET_POST, postsAPI.getPostById);\nfunction* goToHomeSaga() {\n  const history = yield getContext('history');\n  history.push('/');\n}\n// 사가들을 합치기\nexport function* postsSaga() {\n  yield takeEvery(GET_POSTS, getPostsSaga);\n  yield takeEvery(GET_POST, getPostSaga);\n  yield takeEvery(GO_TO_HOME, goToHomeSaga);\n}\n\n(...)</code></pre></div>\n<p>이제 <code class=\"language-text\">GO_TO_HOME</code> 액션이 디스패치되면 / 경로로 이동 될 것입니다.</p>\n<p>이번 튜토리얼에선 리덕스 미들웨어를 다루는 방법에 대해서 알아보았습니다. redux-thunk와 redux-saga의 기본적인 사용법을 알아보았으며, 만약 프로미스를 처리를 하게 될 때에는 어떻게 하면 코드를 깔끔하게 작성 할 수 있는지도 배워보았습니다.</p>\n<p>앞으로 여러분들이 프로젝트를 개발 할 때, 무조건 리덕스 + 리덕스 미들웨어를 사용할 필요는 없습니다. 하지만, 프로젝트의 규모가 커졌을 때, 상태를 전역적으로 사용해야 할 때, 비동기 작업을 자주 하게 될 때 리덕스와 리덕스 미들웨어를 잘 활용하시면 프로젝트를 관리 할 때 큰 도움을 줍니다.\nReference</p>","excerpt":"Testing 테스트의 종류 및 Jest 유닛 테스트, 통합 테스트, 기능 테스트\n유닛 테스트 : 코드가 제대로 작동하는지 확인하기 위해 애플리케이션의 개별 모듈을 독립적으로 테스트(종속성과의 상호 작용없이)하는 것을 의미합니다.\n통합 테스트 : 다른 모듈이 그룹으로 결합될 때 잘 작동하는지 확인하는 것을 의미합니다.\n기능 테스트 : 시스템의 기능 조각(종속성과 상호 작용 할 수 있음)을 테스트하여 코드가 올바른 작업을 수행하는지 확인하는 것을 의미합니다.\n기능 테스트는 통합 테스트와 관련이 있지만, 모든 코드가 함께 실행되는 상태에서 전체 애플리케이션의 기능을 확인하는 테스트를 의미합니다. 단위 테스트는 시슽메의 단일 구성 요소 검사를 고려하는 반면, 기능 테스트는 시스템 요구 사항 사양에 설명 되어 있는 의도 된 기능에 대해 응용 프로그램 작동을 검사하는 것 입니다. 유닛 테스트의 특징\n가장 작은 단위의 테스트이며, 보통 메서드 레벨입니다.\nA라는 함수가 실행되면 B라는 결과가…","frontmatter":{"date":"November 10, 2021","title":"Shop Project_Next js에서 Redux사용해 인증(로그인, 회원가입)","categories":"TIL","author":"yooji","emoji":null},"fields":{"slug":"/TIl_20211110/"}},"next":{"id":"b29b52da-1d5e-5e90-8566-d450954f33e8","html":"<h1 id=\"기능구현-후-성능향상--유지관리\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84-%ED%9B%84-%EC%84%B1%EB%8A%A5%ED%96%A5%EC%83%81--%EC%9C%A0%EC%A7%80%EA%B4%80%EB%A6%AC\" aria-label=\"기능구현 후 성능향상  유지관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기능구현 후 성능향상 &#x26; 유지관리</h1>\n<p>[ 컴포넌트 로딩속도 등을 향상시킴 ] </p>\n<h2 id=\"1익명함수object-사용-자제\" style=\"position:relative;\"><a href=\"#1%EC%9D%B5%EB%AA%85%ED%95%A8%EC%88%98object-%EC%82%AC%EC%9A%A9-%EC%9E%90%EC%A0%9C\" aria-label=\"1익명함수object 사용 자제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.익명함수/object 사용 자제</h2>\n<p>함수나 오브젝트는 변수에 담아쓰는게 좋음. 콜백하마수나 오브젝트 형식이 아닌 컴포넌트 바깥에 있는 변수에 저장해서 불러 씀\n-> 메모리공간을 아끼는 JS 관습\n컴포넌트 재렌더링 시 이름없는(변수에 저장안된) object, function 자료형 → 매번 새로운 메모리 영역을 할당해줘야하기 때문에 컴퓨터 바빠짐</p>\n<h2 id=\"2레이아웃에-애니메이션-사용-자제\" style=\"position:relative;\"><a href=\"#2%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83%EC%97%90-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EC%82%AC%EC%9A%A9-%EC%9E%90%EC%A0%9C\" aria-label=\"2레이아웃에 애니메이션 사용 자제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.레이아웃에 애니메이션 사용 자제</h2>\n<p>애니메이션 넣을 때 성능에 지장 없이 만들려면 자바스크립트, transition을 이용한 레이아웃 변경 애니메이션은 브라우저 입장에서는 큰 부담이니 사용 자제\n(레이아웃: width, margin, padding, left right top bottom 등)<br>\ntransform, opacity 같은 CSS 속성(transform은 사이즈 변경, 좌표이동, 회전 전부 가능한 속성)을 이용해 성능 지장 없게 만들어야함.</p>\n<h2 id=\"3-컴포넌트-lazy-loading-하기\" style=\"position:relative;\"><a href=\"#3-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-lazy-loading-%ED%95%98%EA%B8%B0\" aria-label=\"3 컴포넌트 lazy loading 하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 컴포넌트 lazy loading 하기</h2>\n<p>보통 App.js 라는 메인페이지 방문시 많은 컴포넌트 파일을 import 해오기 때문에 사이트 초기 접속속도가 굉장히 느려짐 (웹앱 사이트들의 특징)\n첫 페이지 방문시 import를 바로 해올 필요없는 컴포넌트는 필요해질 때 import 해달라고 할 수 있음</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, {useState, useContext, lazy, Suspense} from 'react';\nconst Detail = lazy( ()=>{ return import('./Detail.js') } );\n\nrender (\n  &lt;Suspense fallback={ &lt;div>로딩중&lt;/div> }>\n    &lt;Detail/>\n  &lt;/Suspense>\n)</code></pre></div>\n<blockquote>\n<ol>\n<li>react 라이브러리에서 lazy, Suspense를 import </li>\n<li>import Detail 대신 lazy 함수를 이용</li>\n<li><Suspense> 컴포넌트로 <Detail>을 감싸줌</li>\n<li><Detail> 컴포넌트가 필요해질 때 import Detail </li>\n<li><Suspense>의 fallback 속성을 이용해 <Detail> 컴포넌트 로딩 전까지 띄울 HTML 안내문 적을 수 있음</li>\n</ol>\n</blockquote>\n<h2 id=\"4-react-dev-tools-리액트-개발자-도구-크롬-확장프로그램\" style=\"position:relative;\"><a href=\"#4-react-dev-tools-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8F%84%EA%B5%AC-%ED%81%AC%EB%A1%AC-%ED%99%95%EC%9E%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8\" aria-label=\"4 react dev tools 리액트 개발자 도구 크롬 확장프로그램 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. React Dev Tools 리액트 개발자 도구 크롬 확장프로그램</h2>\n<p>크롬으로 구글에 react dev tools 검색해 설치시 크롬브라우저에서 우클릭 -> 검사 누르면 리액트 관련 탭 생김\nComponents탭\n→ 현재 페이지에 사용된 모든 컴포넌트들을 쭉 나열해 보여줌\n컴포넌트를 클릭시 사용중인 props, state, hook 표시해주기 때문에 </p>\n<ul>\n<li>props가 잘 전해졌는지, state가 잘 변하고 있는지 확인</li>\n<li>실시간 state, props 수정해보는것 가능</li>\n<li>시계모양 버튼 → 해당 컴포넌트 렌더링을 잠깐 정지</li>\n</ul>\n<p>Profiler탭\n→ 맨 왼쪽 녹화 버튼(파란점)을 눌러서 컴포넌트 렌더링 속도를 측정 가능\n버튼 누르고 사이트 탐색하고 버튼 다시 누르면 녹화가 완료되며 렌더링된 컴포넌트 다 기록되어 있음</p>\n<ul>\n<li>어떤 컴포넌트가 렌더링 시간이 젤 오래걸리는지</li>\n<li>쓸데없이 재렌더링 자주되는 컴포넌트가 있는지</li>\n<li>렌더링 필요없는 컴포넌트가 있는지 찾아낼 수 있음</li>\n</ul>\n<h2 id=\"5-memo\" style=\"position:relative;\"><a href=\"#5-memo\" aria-label=\"5 memo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. memo</h2>\n<p>리액트 앱은 컴포넌트와 관련된 state 혹은 props가 변경되면 항상 자동 재렌더링 됨 → 사이트 구동 속도가 저하\n컴포넌트의 규모가 너무 커 잦은 재렌더링이 부담스러울 때 쓰는 방법\n특히 컴포넌트안에 컴포넌트가 여러개 있을 때 유용함 (부모 컴포넌트를 구성하는 state나 props가 변경되면 해당 Props를 전달받는 자식 컴포넌트를 전부 자동 재렌더링 시키기 때문)\nmemo로 감싼 컴포넌트는 기존 props와 바뀐 props를 비교하는 연산이 추가로 진행되기 때문에 props가 크고 복잡하면 이거 자체로도 부담이 됨\n규모가 작은 사이트를 만들거나 컴포넌트 내부에 있는 HTML 양이 매우 적을 경우엔 사용 X</p>\n<p>Reference</p>","frontmatter":{"date":"November 09, 2021","title":"Shop Project_성능 최적화","categories":"TIL","author":"yooji","emoji":null},"fields":{"slug":"/TIl_20211109/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.yoojiih.github.io","comments":{"utterances":{"repo":"yoojiih/yoojiih.github.io"}}}}},"pageContext":{"slug":"/TIl_20211110/","nextSlug":"/TIl_20211109/","prevSlug":""}},"staticQueryHashes":["1073350324","2938748437"]}